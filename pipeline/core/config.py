"""YAML config parser. Reads config generated by Next.js Wizard."""

import os
import yaml
from pathlib import Path
from .types import BuildConfig
from .errors import ConfigError


def load_config(config_path: str, output_dir: str) -> BuildConfig:
    path = Path(config_path)
    if not path.exists():
        raise ConfigError(f"Config not found: {config_path}")

    with open(path, 'r', encoding='utf-8') as f:
        raw = yaml.safe_load(f) or {}

    if not isinstance(raw, dict):
        raise ConfigError(f"Invalid config format: {config_path}")

    # Auto-discover transcripts from input dir
    # build-queue.ts layout: data/builds/<id>/input/, output/, config.yaml
    build_dir = Path(output_dir).parent
    search_dirs = [
        build_dir / "input",       # build-queue.ts copies files here
        build_dir / "uploads",     # legacy fallback
    ]
    transcript_exts = {'.txt', '.md', '.srt', '.vtt'}
    transcript_paths = []
    for search_dir in search_dirs:
        if search_dir.exists():
            for p in sorted(search_dir.iterdir()):
                if p.suffix.lower() in transcript_exts and str(p) not in transcript_paths:
                    transcript_paths.append(str(p))

    tier_map = {"draft": "draft", "standard": "standard", "premium": "premium"}

    # Auto-discover unprocessed PDFs in input dir
    pdf_exts = {'.pdf'}
    pdf_paths = []
    for search_dir in search_dirs:
        if search_dir.exists():
            for p in sorted(search_dir.iterdir()):
                if p.suffix.lower() in pdf_exts and str(p) not in pdf_paths:
                    pdf_paths.append(str(p))

    return BuildConfig(
        name=raw.get("name", "Untitled"),
        domain=raw.get("domain", "custom"),
        language=raw.get("language", "vi"),
        quality_tier=tier_map.get(raw.get("quality_tier", "standard"), "standard"),
        platforms=raw.get("platforms", ["claude"]),
        baseline_sources=raw.get("baseline_sources", []),
        transcript_paths=transcript_paths,
        output_dir=output_dir,
        config_path=config_path,
        claude_api_key=os.environ.get("CLAUDE_API_KEY", "") or raw.get("claude_api_key", ""),
        claude_model=raw.get("claude_model", "") or os.environ.get("CLAUDE_MODEL", "claude-sonnet-4-5-20250929"),
        seekers_cache_dir=os.environ.get("SEEKERS_CACHE_DIR", "./data/cache"),
        seekers_cache_ttl_hours=int(os.environ.get("SEEKERS_CACHE_TTL_HOURS", "168")),
        seekers_output_dir=raw.get("seekers_output_dir", ""),
        input_urls=raw.get("input_urls", []),
        input_pdfs=pdf_paths,
        github_repo=raw.get("github_repo", ""),
        github_analyze_code=raw.get("github_analyze_code", True),
        claude_base_url=raw.get("claude_base_url", "") or os.environ.get("CLAUDE_BASE_URL", ""),
        claude_model_light=raw.get("claude_model_light", "") or os.environ.get("CLAUDE_MODEL_LIGHT", "claude-haiku-4-5-20251001"),
    )


def get_tier_params(tier: str) -> dict:
    return {
        "draft": {"max_atoms_per_chunk": 20, "verify_sample_pct": 30, "dedup_threshold": 0.7},
        "standard": {"max_atoms_per_chunk": 15, "verify_sample_pct": 70, "dedup_threshold": 0.8},
        "premium": {"max_atoms_per_chunk": 10, "verify_sample_pct": 100, "dedup_threshold": 0.9},
    }.get(tier, {"max_atoms_per_chunk": 15, "verify_sample_pct": 70, "dedup_threshold": 0.8})
